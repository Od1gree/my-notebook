# 什么是关系模型

* 从表及表的处理方式抽象出来.
* 一个关系 是 一个Table
* 关系模型的三部分组成
    * 描述DB各种数据的基本结构形式: 关系/表
    * 描述表与表之间可能发生的各种操作: 并(∪),差(-),乘积(×),选择(σ),投影(π),交(∩),连接(⨝),除(÷),更名操作
    * 描述这些操作遵循的约束条件:实体完整性,参照完整性,用户自定义的完整性

## 关系模型与关系数据库语言的关系
* 关系运算: 关系代数和关系演算
* 关系演算: 元组演算和域演算
* 元组演算: 基于逻辑的运算
* 关系型操作是一次一个集合,非关系型操作是一次一个记录

>   关系代数语言: π<sub>姓名,课程名</sub>(σ<sub>课程号=c2</sub>(R⨝S))
    基于关系代数设计的数据库语言(ISBL):计算机可识别的符号表征关系代数运算符号: ((R*S):课程号=c2)%姓名,课程名
    元组演算

# 什么是关系
* 域: "列"的取值范围,是一组值的集合,具有相同的数据类型;元素的个数称为域的基数
* 笛卡尔积: 笛卡尔积的每个元素称为n-元组;元组的每一个值d<sub>i</sub>叫做一个分量;元组是从每一个域取一个值所形成的一种集合,笛卡尔积是所有这种可能的组合.
* 关系: 一组域的笛卡尔积的子集. 笛卡尔积中具有某一方面意义的那些元组被称为一个关系(Relation);由于关系的不同列可能来自同一个域,为区分,需要为每一列起一个名字,为属性名(列名).

> 关系可用R(A<sub>1</sub>:D<sub>1</sub>,....)表示,简记为R(A<sub>1</sub>...),表示关系模式,即表标题.
R是关系的名字,A<sub>i</sub>是属性,D<sub>i</sub>是属性所对应的域,n是关系的度或目(degree),关系中元组的数目称为关系的基数(Cardinality)

> 关系模式R中属性向域的映像在DBMS中直接说明为属性的类型,长度等.
Student(S# char(10)), Student为表名,S#属性名,char(10)为域名的类型和长度

## 关系模式与关系
* 同一个模式下,有很多关系
* 关系模式是关系的结构,关系是关系模式在某一时刻的数据
* 关系模式是稳定的, 关系是某一时刻的值,是随时可以变化的.

# 关系的特征及概念
* 列是同质的: 每一列中的分量来自同一域,是同一类型的数据.
> 不同的列可以来自同一个域,称其中的每一列为一个属性,不同的属性要给与不同的属性名. 

* 行/列位置互换性: 区分行/列靠名字和值来区分,不按照位置区分.
* 理论上关系的任意两个元组不能完全相同(每个分量)(即集合的要求),在现实中表可能不完全遵循此特性.
* 属性不可再分特征: 又称为关系第一范式.(而表可能不遵循此特性)

## 候选码/候选键
* 定义: 关系中的一个属性组,其值能唯一标识一个元组,若从该属性组中去掉任何一个属性,它就不具有这个性质了.这样的属性组称为候选码.
> 例如 "学生(S#,Sname)" S#就是一个候选码,在此关系中,任何两个元组的S#是一定不同的,而其他属性都可能相同,因此S#是候选码. 两个属性联合起来也可以称为候选码.

* 有时关系中有多组候选码.当有多个候选码时,可以选定一个作为主码.
* DBMS以主码为主要线索管理关系中的各个元组

## 主属性与非主属性
* 包含在任何一个候选码中的属性被称作主属性,而其他属性被称为非主属性.
> 当所有属性构成这个关系的候选码,则称为全码.

## 外码/外键(Foreign key)
* 关系R中的一个属性组,它不是R的候选码,但是它与另一个关系S的候选码相对应,则成这个属性组为R的外键.
* 外码是连接两个或多个关系的纽带.


# 关系模型的完整性
## 实体完整性
* 关系的主码中的属性不能为空
* 空值: 不知道或无意义的值.用"?"代替
> 有空值后会影响很多计算,他不参与算术运算
* 意义: 若为空则不可区分

## 参照完整性
* 如果关系R1的外码Fk与关系R2的主码Pk对应,则R1中的每一个元组的Fk值等于R2中的某个Pk值也可以为空值.
* 意义: 如果关系R1的某个元组t1参照了关系R2的某个元组t2,则t2必须存在.

## 用户自定义完整性
* 用户针对具体的应用环境定义的完整性约束条件
> 例如对数据的值域的限定

* 实体完整性和参照完整性由DBMS系统自动支持
* DBMS系统提供如下机制:
    * 用户可以自行定义有关的完整性约束条件
    * 当有更新操作发生时,DBMS将自动按照完整性约束条件检验更新操作的正确性,即是否符合用户的自定义完整性.